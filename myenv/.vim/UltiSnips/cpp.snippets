snippet main
int main(int argc, char* argv[])
{
    ${0}

    return 0;
}
endsnippet

snippet cpp
#ifdef __cplusplus
extern "C" {
#endif

${0}

#ifdef __cplusplus
} /* extern "C" */
#endif
endsnippet

snippet def
#ifndef $1
#define ${1:SYMBOL} ${2:value}
#endif /* ifndef $1 */
endsnippet

snippet if
if(${1:true})
{
    ${2:${VISUAL}}
}
else
{
    ${0}
}
endsnippet

snippet for
for(auto i = ${3:0}; i < ${1}; ++i)
{
    ${2}
}
endsnippet

snippet .
{
    ${1}
}
endsnippet

snippet iter
for(auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1)
{
    ${3:std::cout << *$1 << std::endl;}
}
endsnippet

snippet inc
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

endsnippet

snippet std
/*{{{*/
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <tuple>
#include <algorithm>
#include <chrono>
#include <thread>
#include <initializer_list>

using std::cout;
using std::endl;
using std::string;
using std::map;
using std::vector;
using std::shared_ptr;
using std::unique_ptr;
using std::tuple;
using std::make_tuple;
using std::find;
using std::thread;
using std::conditional;
using std::decay;
using std::is_same;
using std::enable_if;
using std::result_of;
using std::is_class;
using std::is_function;
using std::is_convertible;
using std::true_type;
using std::false_type;
using std::to_string;
using std::initializer_list;
using namespace std::chrono;
/*}}}*/

endsnippet

snippet filer
FILE* ${1:fp} = fopen(${2}, "r");
fread(${3}, ${4}, 1, $1);

fclose($1);
endsnippet

snippet filew
FILE* ${1:fp} = fopen(${2}, "w");
fwrite(${3}, ${4}, 1, $1);

fclose($1);
endsnippet

snippet malloc
char* ${1:buff} = malloc(${2});
endsnippet

snippet memset
memset(${1:buff}, 0, sizeof(${2})*${3});
endsnippet

snippet filesize

#include <sys/stat.h>
unsigned long get_file_size(const char *path)
{
    unsigned long filesize = -1;
    struct stat statbuff;
    if(stat(path, &statbuff) < 0)
    {
    	return filesize;
    }
    else
    {
    	filesize = statbuff.st_size;
    }
    return filesize;
}

endsnippet

snippet tt
/*{{{*/
#define MLLOG printf
#ifndef MLLOG
#error "please define MLLOG"
#endif

#include <sys/time.h>

struct MLTIME {
        MLTIME(const char* l = 0):label(l)
        {
            gettimeofday(&t_start, 0);
        }

        ~MLTIME()
        {
            gettimeofday(&t_end, 0);
            long time_diff = (t_end.tv_sec - t_start.tv_sec)*1000 + (t_end.tv_usec - t_start.tv_usec)/1000;
            MLLOG("%s cost time is %ld ms", label, time_diff);
        }
private:
        MLTIME operator =(const MLTIME&);

private:
    struct timeval t_start;
    struct timeval t_end;
    const char* label;
};

/*}}}*/
#define TT MLTIME tt = __func__;

endsnippet


snippet time
#include <sys/time.h>

long long getTimestamp(void)
{
    struct timeval time;
    gettimeofday(&time,NULL);
    long long curtime = ((long long)(time.tv_sec))*1000 + time.tv_usec/1000;
    return curtime;
}

endsnippet

snippet mllog
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <string.h>

static void mllog(const char * fmt, ...)
{
    FILE* fp = fopen("${1:/data/misc/camera/mllog2.txt}", "a+");
/*{{{*/
    if(fp)
    {
        va_list arg;
        char buf[1024 * 4] = {0};
        va_start(arg, fmt);
        vsprintf(buf, fmt,arg);
        va_end(arg);
        fwrite(buf,1,strlen(buf),fp);
        if(buf[strlen(buf)-1] != '\n')
            fwrite("\n",1,1,fp);
        fflush(fp);
        fclose(fp);
    }
/*}}}*/
}
endsnippet

snippet timestr
#include <string>
#include <stdlib.h>

using namespace std;

string getCurrentTimeStr(void)
{
    time_t t = time(NULL);
    char ch[64] = {0};
    strftime(ch, sizeof(ch) - 1, "%Y-%m-%d-%H-%M-%S", localtime(&t));

    return ch;
}

endsnippet

snippet file2str
#include <string>
#include <fstream>
#include <sstream>

using namespace std;

string readFileIntoString(const char* filename)
{
    ifstream ifile(filename);
    ostringstream buf;
    char ch;

    while(buf && ifile.get(ch))
    {
        buf.put(ch);
    }

    return buf.str();
}

endsnippet

snippet fun
${2:void} ${1:foo}($3)
{
    $4
}
endsnippet

snippet class
class ${1:Foo}
{
public:
    // constructor, asssignment, move constructor, move assignment, destructor
    $1() = default;
    $1(const $1&) = delete;
    $1& operator=(const $1&) = delete;
    $1($1&&) = delete;
    $1& operator=($1&&) = delete;
    ~$1(){;}

private:
};
endsnippet

snippet colorprint
/*{{{*/
#include <stdio.h>
#include <stdarg.h>
#define print_none         printf("\033[0m");fflush(stdout);
#define print_red          printf("\033[1;31;40m");
#define print_green        printf("\033[1;32;40m");
#define print_yellow       printf("\033[1;33;40m");
#define print_blue         printf("\033[1;34;40m");
#define print_purple       printf("\033[1;35;40m");
#define print_cyan         printf("\033[1;36;40m");
void yprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_yellow
    vprintf(format, args);
    print_none
    va_end(args);
}

void rprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_red
    vprintf(format, args);
    print_none
    va_end(args);
}

void gprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_green
    vprintf(format, args);
    print_none
    va_end(args);
}

void pprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_purple
    vprintf(format, args);
    print_none
    va_end(args);
}

void bprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_blue
    vprintf(format, args);
    print_none
    va_end(args);
}

void cprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_cyan
    vprintf(format, args);
    print_none
    va_end(args);
}
/*}}}*/

endsnippet

snippet random
#include <random>

int ${1:size} = $2;
std::random_device seed;
std::mt19937 engine(seed());
std::uniform_int_distribution<> uniformDist(0, $1);

int ${3:random_value} = uniformDist(engine);
endsnippet

snippet timespan
#include <chrono>

auto ${1:time_start} = std::chrono::steady_clock::now();

$3

auto ${2:time_end} = std::chrono::steady_clock::now();
auto ${5:duration} = std::chrono::duration_cast<std::chrono::${4:milliseconds}>($2 - $1);
endsnippet

snippet sleep
#include <chrono>
#include <thread>

std::this_thread::sleep_for(std::chrono::${2:milliseconds}($1));
endsnippet

snippet cout
std::cout <<  $1 << std::endl;
endsnippet

snippet cout2
std::cout << "$1 " << $2 << std::endl;
endsnippet

snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vector "std::vector (v)"
std::vector<${1:int}> v$0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:T}>
endsnippet

snippet scanf
FILE* fp = fopen("${1:data.txt}", "r");
#define MAX_LINE 100
char str[MAX_LINE];
int linenum = 0;
while (fgets(str, MAX_LINE, fp) != NULL)
    linenum++;

fseek(fp, 0, SEEK_SET);

int value[linenum];
for(int i = 0; i < linenum; i++)
{
    fscanf(fp, "%d\n", &value[i]);
}

fclose(fp);

endsnippet

snippet asp

#ifndef ML_ARGS_STRING
#define ML_ARGS_STRING

#include <string>
#include <sstream>

inline void args_string(std::ostringstream&) {}

template<typename T, typename ...Args>
inline void args_string(std::ostringstream& stream, T first, Args... rest)
{
    stream << first;
    args_string(stream, rest...);
}

template<typename ...Args>
inline const char* args_string(Args... rest)
{
    std::ostringstream stream;
    args_string(stream, rest...);

    static thread_local std::string str;
    str = stream.str();

    return str.c_str();
}

#define value_name_ml(X) " "#X,":", X

#endif // ML_ARGS_STRING

endsnippet

snippet as
args_string(value_name_ml($1), value_name_ml($2),
            value_name_ml($3), value_name_ml($4),
            value_name_ml($5), value_name_ml($6)
           );
endsnippet

snippet fin
/*{{{*/
template <class F>
class final_action
{
public:
    explicit final_action(F f) noexcept : f_(std::move(f)) {}

    final_action(final_action&& other) noexcept : f_(std::move(other.f_)), invoke_(other.invoke_)
    {
        other.invoke_ = false;
    }

    final_action(const final_action&) = delete;
    final_action& operator=(const final_action&) = delete;
    final_action& operator=(final_action&&) = delete;

    ~final_action() noexcept
    {
        if (invoke_) f_();
    }

private:
    F f_;
    bool invoke_{true};
};

template <class F>
final_action<F> finally_s(const F& f) noexcept
{
    return final_action<F>(f);
}

template <class F>
final_action<F> finally_s(F&& f) noexcept
{
    return final_action<F>(std::forward<F>(f));
}

#define finally_line_cat(c, line) auto mlfinally##line = finally_s([=](){c;});
#define finally_line(c, line) finally_line_cat(c, line)
/*}}}*/
#define finally(c) finally_line(c, __LINE__)

endsnippet

snippet fi
finally(${1:fclose(fp);});
endsnippet

snippet mlt
/*{{{*/
#include <sys/time.h>

#define MLLOG printf
#ifndef MLLOG
#error "please define MLLOG"
#endif

struct MLT{
        MLT(struct timeval start_time, const char* label_tag)
        :t_start(start_time), label(label_tag)
        {
        }

        template <typename T>
        MLT& operator = (T)
        {
            return *this;
        }

        ~MLT()
        {
            gettimeofday(&t_end, 0);
            long time_diff = (t_end.tv_sec - t_start.tv_sec)*1000 + (t_end.tv_usec - t_start.tv_usec)/1000;
            MLLOG("%s cost time is %ld ms\n", label, time_diff);
        }
private:
    struct timeval t_start;
    struct timeval t_end;
    const char* label;
};

MLT mlt_helper(struct timeval start_time, const char* label_tag)
{
    return MLT(start_time, label_tag);
}

// caNNot use for void return functions
// and seems tedious
#define mlt(f)    struct timeval t_start; \
                  gettimeofday(&t_start, 0); \
                  mlt_helper(t_start, #f) = \

/*}}}*/

// cannot use for void return functions
#define mt        struct timeval t_start; \
                  gettimeofday(&t_start, 0); \
                  mlt_helper(t_start, "") = \

endsnippet

snippet fr
unique_ptr<unsigned char[]> p = [](const char* path)
                                {
                                    using uchar = unsigned char;
                                    unique_ptr<uchar[]> p;
                                    int fs;
                                    if(FILE* f;(0  == access(path, F_OK | R_OK)) &&
                                       (f  = fopen(path, "r")) &&
                                       (0  == fseek(f, 0, SEEK_END)) &&
                                       (fs = ftell(f)) &&
                                       (0  == fseek(f, 0, SEEK_SET)) &&
                                       (p  = unique_ptr<uchar[]>(new uchar[fs])) &&
                                       (fs == fread(p.get(), fs, 1, f)) &&
                                       (0  == fclose(f))
                                      )return p;
                                }(${1});

endsnippet

snippet once
#pragma once

endsnippet

snippet ifn
#ifndef $1

#define ${1} ${2}

#endif

endsnippet

snippet arr

#include <memory>

template <typename T>
std::shared_ptr<T> make_shared_array(size_t size)
{
    return std::shared_ptr<T>(new T[size], std::default_delete<T[]>());
}

endsnippet

snippet rc

/*{{{*/
#ifndef NDEBUG
#include <assert.h>

template <class T>
class CheckReturnML
{
public:

    CheckReturnML(const T& value) :
        value(value), check(true){}

    ~CheckReturnML()
    {
        if(check)
            assert("must check return value" == nullptr);
    }

    operator T(void)
    {
        check = false;

        return value;
    }

private:
    T value;
    mutable bool check;
};

#define CRML(x) using x##c = CheckReturnML<x>; \
                using u##x##c = CheckReturnML<unsigned x>;
CRML(char)
CRML(short)
CRML(int)
CRML(long)
using longlongc = CheckReturnML<long long>;
using ulonglongc = CheckReturnML<unsigned long long>;

#else // !NDEBUG

#define CRML(x) using x##c = x; \
                using u##x##c = unsigned x;
CRML(char)
CRML(short)
CRML(int)
CRML(long)
using longlongc = long long;
using ulonglongc = unsigned long long;

#endif // !!NDEBUG
/*}}}*/

endsnippet

snippet ret

#ifndef MLLOG
#define MLLOG printf
#endif

#define return if(MLLOG("returned from %s:%d\n", __func__, __LINE__) || true) \
               return 

#undef return

endsnippet

snippet type

/*{{{*/
#include <type_traits>
#include <typeinfo>
#include <memory>
#include <string>
#include <cstdlib>

#include <cxxabi.h>
/*}}}*/

template <class T>
std::string type_name(void)
/*{{{*/
{
    typedef typename std::remove_reference<T>::type TR;

    std::unique_ptr<char, void(*)(void*)> own
	    (
	    abi::__cxa_demangle(typeid(TR).name(), nullptr,
	    nullptr, nullptr),
	    std::free
	    );

    std::string r = own != nullptr ? own.get() : typeid(TR).name();
    if (std::is_const<TR>::value)
	    r += " const";
    if (std::is_volatile<TR>::value)
	    r += " volatile";
    if (std::is_lvalue_reference<T>::value)
	    r += "&";
    else if (std::is_rvalue_reference<T>::value)
	    r += "&&";

    return r;
}
/*}}}*/

endsnippet

snippet member

/*{{{*/
#include <type_traits>
#include <utility>

namespace detail {

    template <class T, std::size_t N>
    struct array {
        typedef T type;
        T data[N];

        static constexpr std::size_t size() noexcept { return N; }
    };

    template <class Array>
    constexpr auto count_nonzeros(Array a) noexcept {
        std::size_t count = 0;
        for (std::size_t i = 0; i < Array::size() && a.data[i]; ++i)
            ++ count;

        return count;
    }

    template <class T> struct identity{};

    constexpr auto id_to_type( std::integral_constant<std::size_t, 20 > ) noexcept { size_t res{}; return res; }

#define REGISTER_TYPE(Type, Index)                                              \
    constexpr std::size_t type_to_id(identity<Type>) noexcept { return Index; } \
    constexpr auto id_to_type( std::integral_constant<std::size_t, Index > ) noexcept { Type res{}; return res; }  \

    REGISTER_TYPE(unsigned short        , 1)
    REGISTER_TYPE(unsigned int          , 2)
    REGISTER_TYPE(unsigned long long    , 3)
    REGISTER_TYPE(signed char           , 4)
    REGISTER_TYPE(short                 , 5)
    REGISTER_TYPE(int                   , 6)
    REGISTER_TYPE(long long             , 7)
    REGISTER_TYPE(unsigned char         , 8)
    REGISTER_TYPE(char                  , 9)
    REGISTER_TYPE(wchar_t               , 10)
    REGISTER_TYPE(long                  , 11)
    REGISTER_TYPE(unsigned long         , 12)
    REGISTER_TYPE(void*                 , 13)
    REGISTER_TYPE(const void*           , 14)
    REGISTER_TYPE(char16_t              , 15)
    REGISTER_TYPE(char32_t              , 16)
    REGISTER_TYPE(float                 , 17)
    REGISTER_TYPE(double                , 18)
    REGISTER_TYPE(long double           , 19)


    constexpr std::size_t native_types_mask = 255;
    constexpr std::size_t bits_per_extension = 2;
    constexpr std::size_t native_ptr_type = (
            static_cast<std::size_t>(1)
                    << static_cast<std::size_t>(sizeof(std::size_t) * 8 - bits_per_extension)
    );
    constexpr std::size_t native_const_ptr_type = (
            static_cast<std::size_t>(2)
                    << static_cast<std::size_t>(sizeof(std::size_t) * 8 - bits_per_extension)
    );

    template <class Type>
    constexpr std::size_t type_to_id_extension_apply(identity<Type>, std::size_t ext) noexcept {
        constexpr auto unptr = type_to_id(identity<Type>{});
        constexpr auto native_id = (unptr & native_types_mask);
        constexpr auto extensions = (unptr & ~native_types_mask);
        static_assert(
                !((extensions >> bits_per_extension) & native_types_mask),
                "max extensions reached"
        );
        return (extensions >> bits_per_extension) | native_id | ext;
    }


    template <class Type>
    constexpr std::size_t type_to_id(identity<Type*>) noexcept {
        return type_to_id_extension_apply(identity<Type>{}, native_ptr_type);
    }

    template <class Type>
    constexpr std::size_t type_to_id(identity<const Type*>) noexcept {
        return type_to_id_extension_apply(identity<Type>{}, native_const_ptr_type);
    }

    template <std::size_t Index>
    constexpr auto id_to_type(
            std::integral_constant<std::size_t, Index >,
            typename std::enable_if< !!(Index & native_const_ptr_type) >::type* = 0) noexcept;


    template <std::size_t Index>
    constexpr auto id_to_type(
            std::integral_constant<std::size_t, Index >,
            typename std::enable_if< !!(Index & native_ptr_type) >::type* = 0) noexcept
    {
        auto t = id_to_type(
                std::integral_constant<
                        std::size_t,
                        ((Index & ~native_types_mask) << 2) | (Index & native_types_mask)
                >{}
        );
        decltype(t)* res{};
        return res;
    }

    template <std::size_t Index>
    constexpr auto id_to_type(
            std::integral_constant<std::size_t, Index >,
            typename std::enable_if< !!(Index & native_const_ptr_type) >::type*) noexcept
    {
        auto t = id_to_type(
                std::integral_constant<
                        std::size_t,
                        ((Index & ~native_types_mask) << 2) | (Index & native_types_mask)
                >{}
        );

        const decltype(t)* res{};
        return res;
    }


    template <std::size_t I>
    struct ubiq {
        std::size_t* ref_;

        template <class Type>
        constexpr operator Type() const noexcept {
            ref_[I] = type_to_id(identity<Type>{});
            return Type{};
        }
    };

    template <class T, std::size_t... I>
    constexpr auto type_to_array_of_type_ids(std::size_t* types) noexcept -> decltype(T{ ubiq<I>{types}... }) {
        return T{ ubiq<I>{types}... };
    }

    template <class T, std::size_t I0, std::size_t... I>
    constexpr auto detect_fields_count_and_type_ids(std::size_t* types, std::index_sequence<I0, I...>) noexcept
    -> decltype( type_to_array_of_type_ids<T, I0, I...>(types) )
    {
        return type_to_array_of_type_ids<T, I0, I...>(types);
    }

    template <class T, std::size_t... I>
    constexpr T detect_fields_count_and_type_ids(std::size_t* types, std::index_sequence<I...>) noexcept {
        return detect_fields_count_and_type_ids<T>(types, std::make_index_sequence<sizeof...(I) - 1>{});
    }

    template <class T>
    constexpr T detect_fields_count_and_type_ids(std::size_t*, std::index_sequence<>) noexcept {
        static_assert(!!sizeof(T), "Failed for unknown reason");
        return T{};
    }


    template <class T>
    constexpr auto fields_count_and_type_ids_with_zeros() noexcept {
        static_assert(std::is_trivial<T>::value, "Not applyable");
        array<std::size_t, sizeof(T)> types{};
        detect_fields_count_and_type_ids<T>(types.data, std::make_index_sequence<sizeof(T)>{});
        return types;
    }

} // namespace detail

/*}}}*/

template <class T>
constexpr auto get_struct_member_count(void)
{
    constexpr auto types = detail::fields_count_and_type_ids_with_zeros<T>();

    return detail::count_nonzeros(types);
}

endsnippet

snippet s2s

/*{{{*/
#include <string>
#include <sstream>

inline void args_string(std::ostringstream&) {}

template <typename T>
inline auto char2int(T t)
{
    return t;
}

template <>
inline auto char2int(char t)
{
    return (int)t;
}

template <>
inline auto char2int(unsigned char t)
{
    return (int)t;
}

template<typename T>
inline void args_string(std::ostringstream& stream, T last)
{
    stream << char2int(last) << "}";
}

template<typename T, typename ...Args>
inline void args_string(std::ostringstream& stream, T first, Args... rest)
{
    stream << char2int(first) << ", ";
    args_string(stream, rest...);
}

template<typename ...Args>
inline const char* args_string(Args... rest)
{
    std::ostringstream stream;
    stream << "{";
    args_string(stream, rest...);

    static thread_local std::string str;
    str = stream.str();

    return str.c_str();
}

#include <type_traits>
#include <utility>
#include <iostream>
#include <tuple>

namespace sequence_tuple {
    template <std::size_t N, class T>
    struct base_from_member {
        T value;
    };

    template <class I, class ...Tail>
    struct tuple_base;

    template <std::size_t... I, class ...Tail>
    struct tuple_base< std::index_sequence<I...>, Tail... >
            : base_from_member<I , Tail>...
    {
        static constexpr std::size_t size_v = sizeof...(I);

        constexpr tuple_base() noexcept = default;
        constexpr tuple_base(tuple_base&&) noexcept = default;
        constexpr tuple_base(const tuple_base&) noexcept = default;

        constexpr tuple_base(Tail... v) noexcept
                : base_from_member<I, Tail>{ v }...
        {}
    };

    template <>
    struct tuple_base<std::index_sequence<> > {
        static constexpr std::size_t size_v = 0;
    };

    template <std::size_t N, class T>
    constexpr T& get_impl(base_from_member<N, T>& t) noexcept {
        return t.value;
    }

    template <std::size_t N, class T>
    constexpr const T& get_impl(const base_from_member<N, T>& t) noexcept {
        return t.value;
    }

    template <std::size_t N, class T>
    constexpr volatile T& get_impl(volatile base_from_member<N, T>& t) noexcept {
        return t.value;
    }

    template <std::size_t N, class T>
    constexpr const volatile T& get_impl(const volatile base_from_member<N, T>& t) noexcept {
        return t.value;
    }

    template <std::size_t N, class T>
    constexpr T&& get_impl(base_from_member<N, T>&& t) noexcept {
        return std::forward<T>(t.value);
    }

    template <class ...Values>
    struct tuple: tuple_base<
            std::make_index_sequence<sizeof...(Values)>,
            Values...>
    {
        using tuple_base<
                std::make_index_sequence<sizeof...(Values)>,
                Values...
        >::tuple_base;
    };


    template <std::size_t N, class ...T>
    constexpr decltype(auto) get(tuple<T...>& t) noexcept {
        static_assert(N < tuple<T...>::size_v, "Tuple index out of bounds");
        return get_impl<N>(t);
    }

    template <std::size_t N, class ...T>
    constexpr decltype(auto) get(const tuple<T...>& t) noexcept {
        static_assert(N < tuple<T...>::size_v, "Tuple index out of bounds");
        return get_impl<N>(t);
    }

    template <std::size_t N, class ...T>
    constexpr decltype(auto) get(const volatile tuple<T...>& t) noexcept {
        static_assert(N < tuple<T...>::size_v, "Tuple index out of bounds");
        return get_impl<N>(t);
    }

    template <std::size_t N, class ...T>
    constexpr decltype(auto) get(volatile tuple<T...>& t) noexcept {
        static_assert(N < tuple<T...>::size_v, "Tuple index out of bounds");
        return get_impl<N>(t);
    }

    template <std::size_t N, class ...T>
    constexpr decltype(auto) get(tuple<T...>&& t) noexcept {
        static_assert(N < tuple<T...>::size_v, "Tuple index out of bounds");
        return get_impl<N>(std::move(t));
    }

    template <size_t I, class T>
    using tuple_element = std::remove_reference< decltype(
    sequence_tuple::get<I>( std::declval<T>() )
    ) >;

} // namespace sequence_tuple

namespace detail {

    template <class T, std::size_t N>
    struct array {
        typedef T type;
        T data[N];

        static constexpr std::size_t size() noexcept { return N; }
    };

    template <std::size_t I, class T, std::size_t N>
    constexpr const T& get(const array<T,N>& a) noexcept {
        return a.data[I];
    }

    template <class Array>
    constexpr auto count_nonzeros(Array a) noexcept {
        std::size_t count = 0;
        for (std::size_t i = 0; i < Array::size() && a.data[i]; ++i)
            ++ count;

        return count;
    }

    template <class T> struct identity{};

    constexpr auto id_to_type( std::integral_constant<std::size_t, 20 > ) noexcept { size_t res{}; return res; }

#define REGISTER_TYPE(Type, Index)                                              \
    constexpr std::size_t type_to_id(identity<Type>) noexcept { return Index; } \
    constexpr auto id_to_type( std::integral_constant<std::size_t, Index > ) noexcept { Type res{}; return res; }  \
    /**/


// Register all base types here
    REGISTER_TYPE(unsigned short        , 1)
    REGISTER_TYPE(unsigned int          , 2)
    REGISTER_TYPE(unsigned long long    , 3)
    REGISTER_TYPE(signed char           , 4)
    REGISTER_TYPE(short                 , 5)
    REGISTER_TYPE(int                   , 6)
    REGISTER_TYPE(long long             , 7)
    REGISTER_TYPE(unsigned char         , 8)
    REGISTER_TYPE(char                  , 9)
    REGISTER_TYPE(wchar_t               , 10)
    REGISTER_TYPE(long                  , 11)
    REGISTER_TYPE(unsigned long         , 12)
    REGISTER_TYPE(void*                 , 13)
    REGISTER_TYPE(const void*           , 14)
    REGISTER_TYPE(char16_t              , 15)
    REGISTER_TYPE(char32_t              , 16)
    REGISTER_TYPE(float                 , 17)
    REGISTER_TYPE(double                , 18)
    REGISTER_TYPE(long double           , 19)


    constexpr std::size_t native_types_mask = 255;
    constexpr std::size_t bits_per_extension = 2;
    constexpr std::size_t native_ptr_type = (
            static_cast<std::size_t>(1)
                    << static_cast<std::size_t>(sizeof(std::size_t) * 8 - bits_per_extension)
    );
    constexpr std::size_t native_const_ptr_type = (
            static_cast<std::size_t>(2)
                    << static_cast<std::size_t>(sizeof(std::size_t) * 8 - bits_per_extension)
    );

    template <class Type>
    constexpr std::size_t type_to_id_extension_apply(identity<Type>, std::size_t ext) noexcept {
        constexpr auto unptr = type_to_id(identity<Type>{});
        constexpr auto native_id = (unptr & native_types_mask);
        constexpr auto extensions = (unptr & ~native_types_mask);
        static_assert(
                !((extensions >> bits_per_extension) & native_types_mask),
                "max extensions reached"
        );
        return (extensions >> bits_per_extension) | native_id | ext;
    }


    template <class Type>
    constexpr std::size_t type_to_id(identity<Type*>) noexcept {
        return type_to_id_extension_apply(identity<Type>{}, native_ptr_type);
    }

    template <class Type>
    constexpr std::size_t type_to_id(identity<const Type*>) noexcept {
        return type_to_id_extension_apply(identity<Type>{}, native_const_ptr_type);
    }

    template <std::size_t Index>
    constexpr auto id_to_type(
            std::integral_constant<std::size_t, Index >,
            typename std::enable_if< !!(Index & native_const_ptr_type) >::type* = 0) noexcept;


    template <std::size_t Index>
    constexpr auto id_to_type(
            std::integral_constant<std::size_t, Index >,
            typename std::enable_if< !!(Index & native_ptr_type) >::type* = 0) noexcept
    {
        auto t = id_to_type(
                std::integral_constant<
                        std::size_t,
                        ((Index & ~native_types_mask) << 2) | (Index & native_types_mask)
                >{}
        );
        decltype(t)* res{};
        return res;
    }

    template <std::size_t Index>
    constexpr auto id_to_type(
            std::integral_constant<std::size_t, Index >,
            typename std::enable_if< !!(Index & native_const_ptr_type) >::type*) noexcept
    {
        auto t = id_to_type(
                std::integral_constant<
                        std::size_t,
                        ((Index & ~native_types_mask) << 2) | (Index & native_types_mask)
                >{}
        );

        const decltype(t)* res{};
        return res;
    }


    template <std::size_t I>
    struct ubiq {
        std::size_t* ref_;

        template <class Type>
        constexpr operator Type() const noexcept {
            ref_[I] = type_to_id(identity<Type>{});
            return Type{};
        }
    };

    template <class T, std::size_t... I>
    constexpr auto type_to_array_of_type_ids(std::size_t* types) noexcept -> decltype(T{ ubiq<I>{types}... }) {
        return T{ ubiq<I>{types}... };
    }

    template <class T, std::size_t I0, std::size_t... I>
    constexpr auto detect_fields_count_and_type_ids(std::size_t* types, std::index_sequence<I0, I...>) noexcept
    -> decltype( type_to_array_of_type_ids<T, I0, I...>(types) )
    {
        return type_to_array_of_type_ids<T, I0, I...>(types);
    }

    template <class T, std::size_t... I>
    constexpr T detect_fields_count_and_type_ids(std::size_t* types, std::index_sequence<I...>) noexcept {
        return detect_fields_count_and_type_ids<T>(types, std::make_index_sequence<sizeof...(I) - 1>{});
    }

    template <class T>
    constexpr T detect_fields_count_and_type_ids(std::size_t*, std::index_sequence<>) noexcept {
        static_assert(!!sizeof(T), "Failed for unknown reason");
        return T{};
    }


    template <class T>
    constexpr auto fields_count_and_type_ids_with_zeros() noexcept {
        static_assert(std::is_trivial<T>::value, "Not applyable");
        array<std::size_t, sizeof(T)> types{};
        detect_fields_count_and_type_ids<T>(types.data, std::make_index_sequence<sizeof(T)>{});
        return types;
    }


    template <class T>
    constexpr auto array_of_type_ids() noexcept {
        constexpr auto types = fields_count_and_type_ids_with_zeros<T>();
        constexpr std::size_t count = count_nonzeros(types);
        array<std::size_t, count> res{};
        for (std::size_t i = 0; i < count; ++i) {
            res.data[i] = types.data[i];
        }

        return res;
    }


    template <class T, std::size_t... I>
    constexpr auto array_of_type_ids_to_index_sequence(std::index_sequence<I...>) noexcept {
        constexpr auto a = array_of_type_ids<T>();
        return std::index_sequence< get<I>(a)...>{};
    }

    template <class T, std::size_t... I>
    constexpr auto as_tuple_impl(std::index_sequence<I...>) noexcept {
        constexpr auto a = array_of_type_ids<T>();
        return sequence_tuple::tuple<
                decltype(id_to_type(std::integral_constant<std::size_t, I>{}))...
        >{};
    }

    template <class T>
    constexpr sequence_tuple::tuple<> as_tuple_impl(std::index_sequence<>) noexcept {
        return sequence_tuple::tuple<>{};
    }

    template <class T>
    constexpr auto as_tuple() noexcept {
        typedef typename std::remove_cv<T>::type type;

        static_assert(std::is_pod<type>::value, "Not applyable");
        static_assert(!std::is_reference<type>::value, "Not applyable");
        constexpr auto res = as_tuple_impl<type>(
                array_of_type_ids_to_index_sequence<T>(
                        std::make_index_sequence< decltype(array_of_type_ids<T>())::size() >()
                )
        );

        static_assert(
                std::alignment_of<decltype(res)>::value == std::alignment_of<type>::value,
                "Alignment check failed, probably your structure has user-defined alignment for the whole structure or for some of the fields."
        );
        static_assert(sizeof(res) == sizeof(type), "Size check failed, probably your structure has bitfields or user-defined alignment.");

        return res;
    }
} // namespace detail

template <std::size_t I, class T>
decltype(auto) get(const T& val) noexcept {
    auto t = reinterpret_cast<const decltype(detail::as_tuple<T>())*>( std::addressof(val) );
    return get<I>(*t);
}

template <class T>
constexpr std::size_t tuple_size() noexcept {
    return decltype(detail::as_tuple<T>())::size_v;
}

template <std::size_t... I, class T>
const char* s2s(T& f, std::index_sequence<I...>) {
    return args_string(get<I>(f)...);
}

template <class T>
const char* s2s(T& f)
{
    return s2s(f, std::make_index_sequence<tuple_size<T>()>{});
}
/*}}}*/
endsnippet

snippet mlp

/*{{{*/
#include <string>
#include <sstream>

namespace ml
{
inline void args_string_f(std::ostringstream& stream)
{
    stream << "\n";
}

template<typename T, typename ...Args>
inline void args_string_f(std::ostringstream& stream, T first, Args... rest)
{
    stream << first;
    if constexpr(sizeof...(rest)%2)
        stream << ": ";
    else if constexpr(sizeof...(rest))
        stream << ", ";
    args_string_f(stream, rest...);
}

template<typename ...Args>
inline const char* args_string_f(Args... rest)
{
    static_assert(sizeof...(rest)%2 == 0, "args_string_f must use pairs");

    std::ostringstream stream;
    args_string_f(stream, rest...);

    static thread_local std::string str;
    str = stream.str();

    return str.c_str();
}
} // ml
#define S_ ml::args_string_f

#include <type_traits>

namespace ml
{
using std::true_type;
using std::false_type;;
using std::is_function;;
using std::remove_pointer;
using std::conditional;
using std::is_class;
using std::remove_reference;

struct __is_callable_base { void operator()(); };

template <class _T>
struct __is_callable_derived : _T, __is_callable_base {};

template <class _T, _T>
struct __is_callable_check { typedef void _Type; };

template <class _T, class = void>
struct __is_callable_class : true_type {};

template <class _T>
struct __is_callable_class<_T,
  typename __is_callable_check<void (__is_callable_base::*)(),
    &__is_callable_derived<_T>::operator()>::_Type> : false_type {};

template <class _T>
struct __is_callable_function :
  is_function<typename remove_pointer<typename remove_reference<_T>::type>::type> {};

template <class _T>
struct __is_callable :
  conditional<is_class<_T>::value,
    __is_callable_class<_T>, __is_callable_function<_T>>::type {};

} // ml
/*}}}*/

void mllog(const char * fmt, ...);
template <typename C, typename ...Args>
void mlp(C c, Args... args)
{
    if constexpr(ml::__is_callable<C>::value)
        c(S_(args...));
    else
        mllog(S_(c, args...));
}
endsnippet

snippet index

#include <initializer_list>
#include <utility>

using std::initializer_list;

template <std::size_t... I>
auto num2list_impl(std::index_sequence<I...>)
{
    return initializer_list<int>{I...};
}

template <size_t N, typename Indices = std::make_index_sequence<N>>
auto num2list(void)
{
    return num2list_impl(Indices{});
}

endsnippet

snippet forr

#define forr(x, y) for(auto x = 0; x < y; ++x)

endsnippet

snippet sprintf

    char ${1:name}[256];
    snprintf($1, sizeof($1), "${4}", ${2}, ${3});

endsnippet

snippet filename

#define filename(x) strrchr(x,'/')?strrchr(x,'/')+1:x

#define FILENAME filename(__FILE__)

endsnippet

snippet ee

#define MLLOG printf
#ifndef MLLOG
#error "please define MLLOG"
#endif

struct EnterExit {
        EnterExit(const char* l = 0):label(l)
        {
            MLLOG("%s enter", label);
        }

        ~EnterExit()
        {
            MLLOG("%s exit", label);
        }

private:
    const char* label;
};

#define EE  EnterExit ee = __func__;

endsnippet

snippet co
#include <iostream>
using std::cout;
using std::endl;

endsnippet

snippet bb

#define ML_BENCHMARK

/*{{{*/
#ifdef ML_BENCHMARK

#define MLLOG printf
#ifndef MLLOG
#error "please define MLLOG"
#endif

#include <sys/time.h>
#include <string>
#include <memory>
using std::string;
using std::move;

struct MLTIME {
        explicit MLTIME(string& l):label(l)
        {
            gettimeofday(&t_start, 0);
        }

        explicit MLTIME(string&& l):label(move(l))
        {
            gettimeofday(&t_start, 0);
        }

        ~MLTIME()
        {
            gettimeofday(&t_end, 0);
            long time_diff = (t_end.tv_sec - t_start.tv_sec)*1000 + (t_end.tv_usec - t_start.tv_usec)/1000;
            MLLOG("%s cost time is %ld ms\n", label.c_str(), time_diff);
        }
private:
        MLTIME operator =(const MLTIME&);

private:
    struct timeval t_start;
    struct timeval t_end;
    string label;
};

struct EnterExit {
        explicit EnterExit(string& l):label(l)
        {
            MLLOG("%s enter\n", label.c_str());
        }

        explicit EnterExit(string&& l):label(move(l))
        {
            MLLOG("%s enter\n", label.c_str());
        }

        ~EnterExit()
        {
            MLLOG("%s exit\n", label.c_str());
        }

private:
    string label;
};

#endif // ML_BENCHMARK
/*}}}*/

endsnippet

snippet exp
#include <initializer_list>
template<typename F, typename ...Args>void expand(F&& f, Args&& ...args)
{
  std::initializer_list<int>{((std::forward<F>(f))(std::forward<Args>(args)), 0)...};
}

endsnippet
