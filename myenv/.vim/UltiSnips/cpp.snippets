snippet main
int main(int argc, char* argv[])
{
    ${0}

    return 0;
}
endsnippet

snippet cpp
#ifdef __cplusplus
extern "C" {
#endif

${0}

#ifdef __cplusplus
} /* extern "C" */
#endif
endsnippet

snippet def
#ifndef $1
#define ${1:SYMBOL} ${2:value}
#endif /* ifndef $1 */
endsnippet

snippet if
if(${1:true})
{
    ${2:${VISUAL}}
}
else
{
    ${0}
}
endsnippet

snippet for
for(${1})
{
    ${2}
}
endsnippet

snippet .
{
    ${1}
}
endsnippet

snippet iter
for(auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1)
{
    ${3:std::cout << *$1 << std::endl;}
}
endsnippet

snippet inc
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

endsnippet

snippet std
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <tuple>
#include <algorithm>
#include <chrono>
#include <thread>

using std::cout;
using std::endl;
using std::string;
using std::map;
using std::vector;
using std::shared_ptr;
using std::unique_ptr;
using std::tuple;
using std::make_tuple;
using std::find;
using std::thread;
using namespace std::chrono;

endsnippet

snippet filer
FILE* ${1:fp} = fopen(${2}, "r");
fread(${3}, ${4}, 1, $1);

fclose($1);
endsnippet

snippet filew
FILE* ${1:fp} = fopen(${2}, "w");
fwrite(${3}, ${4}, 1, $1);

fclose($1);
endsnippet

snippet malloc
char* ${1:buff} = malloc(${2});
endsnippet


snippet filesize

#include <sys/stat.h>
unsigned long get_file_size(const char *path)
{
    unsigned long filesize = -1;
    struct stat statbuff;
    if(stat(path, &statbuff) < 0)
    {
    	return filesize;
    }
    else
    {
    	filesize = statbuff.st_size;
    }
    return filesize;
}

endsnippet

snippet mltime
#include <sys/time.h>

struct MLTIME {
        MLTIME(const char* l = 0):label(l)
        {
            gettimeofday(&t_start, 0);
        }

        ~MLTIME()
        {
            gettimeofday(&t_end, 0);
            long time_diff = (t_end.tv_sec - t_start.tv_sec)*1000 + (t_end.tv_usec - t_start.tv_usec)/1000;
            logToFile("%s cost time is %ld ms", label, time_diff);
        }
private:
        MLTIME operator =(const MLTIME&);

private:
    struct timeval t_start;
    struct timeval t_end;
    const char* label;
};

#define T MLTIME t = __func__;

endsnippet


snippet time
#include <sys/time.h>

long long getTimestamp(void)
{
    struct timeval time;
    gettimeofday(&time,NULL);
    long long curtime = ((long long)(time.tv_sec))*1000 + time.tv_usec/1000;
    return curtime;
}

endsnippet

snippet mllog
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void mllog(const char * fmt, ...)
{
    FILE* fp = fopen(${1:"/data/misc/camera/mllog2.txt"}, "a+");
    if(fp)
    {
        va_list arg;
        char buf[1024 * 4] = {0};
        va_start(arg, fmt);
        vsprintf(buf, fmt,arg);
        va_end(arg);
        fwrite(buf,1,strlen(buf),fp);
        if(buf[strlen(buf)-1] != '\n')
            fwrite("\n",1,1,fp);
        fflush(fp);
        fclose(fp);
    }
}
endsnippet

snippet timestr
#include <string>
#include <stdlib.h>

using namespace std;

string getCurrentTimeStr(void)
{
    time_t t = time(NULL);
    char ch[64] = {0};
    strftime(ch, sizeof(ch) - 1, "%Y-%m-%d-%H-%M-%S", localtime(&t));

    return ch;
}

endsnippet

snippet file2str
#include <string>
#include <fstream>
#include <sstream>

using namespace std;

string readFileIntoString(const char* filename)
{
    ifstream ifile(filename);
    ostringstream buf;
    char ch;

    while(buf && ifile.get(ch))
    {
        buf.put(ch);
    }

    return buf.str();
}

endsnippet

snippet fun
${2:void} ${1:name}($3)
{
    $4
}
endsnippet

snippet class
class ${1:Class}
{
public:
    // constructor, asssignment, move constructor, move assignment, destructor
    $1() = default;
    $1(const $1&) = delete;
    $1& operator=(const $1&) = delete;
    $1($1&&) = delete;
    $1& operator=($1&&) = delete;
    ~$1();

private:
};
endsnippet

snippet colorprint
#include <stdio.h>
#include <stdarg.h>
#define print_none         printf("\033[0m");fflush(stdout);
#define print_red          printf("\033[1;31;40m");
#define print_green        printf("\033[1;32;40m");
#define print_yellow       printf("\033[1;33;40m");
#define print_blue         printf("\033[1;34;40m");
#define print_purple       printf("\033[1;35;40m");
#define print_cyan         printf("\033[1;36;40m");
void yprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_yellow
    vprintf(format, args);
    print_none
    va_end(args);
}

void rprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_red
    vprintf(format, args);
    print_none
    va_end(args);
}

void gprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_green
    vprintf(format, args);
    print_none
    va_end(args);
}

void pprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_purple
    vprintf(format, args);
    print_none
    va_end(args);
}

void bprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_blue
    vprintf(format, args);
    print_none
    va_end(args);
}

void cprintf(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    print_cyan
    vprintf(format, args);
    print_none
    va_end(args);
}

endsnippet

snippet random
#include <random>

int ${1:size} = $2;
std::random_device seed;
std::mt19937 engine(seed());
std::uniform_int_distribution<> uniformDist(0, $1);

int ${3:random_value} = uniformDist(engine);
endsnippet

snippet timespan
#include <chrono>

auto ${1:time_start} = std::chrono::steady_clock::now();

$3

auto ${2:time_end} = std::chrono::steady_clock::now();
auto ${5:duration} = std::chrono::duration_cast<std::chrono::${4:milliseconds}>($2 - $1);
endsnippet

snippet sleep
#include <chrono>
#include <thread>

std::this_thread::sleep_for(std::chrono::${2:milliseconds}($1));
endsnippet

snippet cout
std::cout << "$1 " << $2 << std::endl;
endsnippet

snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vector "std::vector (v)"
std::vector<${1:int}> v$0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet scanf
FILE* fp = fopen("${1:data.txt}", "r");
#define MAX_LINE 100
char str[MAX_LINE];
int linenum = 0;
while (fgets(str, MAX_LINE, fp) != NULL)
    linenum++;

fseek(fp, 0, SEEK_SET);

int value[linenum];
for(int i = 0; i < linenum; i++)
{
    fscanf(fp, "%d\n", &value[i]);
}

fclose(fp);

endsnippet

snippet asp
#include <string>
#include <sstream>

inline void args_string(std::ostringstream&) {}

template<typename T, typename ...Args>
inline void args_string(std::ostringstream& stream, T first, Args... rest)
{
    stream << first;
    args_string(stream, rest...);
}

template<typename ...Args>
inline const char* args_string(Args... rest)
{
    std::ostringstream stream;
    args_string(stream, rest...);

    static thread_local std::string str;
    str = stream.str();

    return str.c_str();
}

#define value_name_ml(X) " "#X,":", X

endsnippet

snippet as
args_string(value_name_ml($1), value_name_ml($2),
            value_name_ml($3), value_name_ml($4),
            value_name_ml($5), value_name_ml($6)
           );
endsnippet

snippet fin
template <class F>
class final_action
{
public:
    explicit final_action(F f) noexcept : f_(std::move(f)) {}

    final_action(final_action&& other) noexcept : f_(std::move(other.f_)), invoke_(other.invoke_)
    {
        other.invoke_ = false;
    }

    final_action(const final_action&) = delete;
    final_action& operator=(const final_action&) = delete;
    final_action& operator=(final_action&&) = delete;

    ~final_action() noexcept
    {
        if (invoke_) f_();
    }

private:
    F f_;
    bool invoke_{true};
};

template <class F>
final_action<F> finally_s(const F& f) noexcept
{
    return final_action<F>(f);
}

template <class F>
final_action<F> finally_s(F&& f) noexcept
{
    return final_action<F>(std::forward<F>(f));
}

#define finally(c) auto mlfinally = finally_s([=](){c});

endsnippet

snippet fi
finally(${1:fclose(fp);});
endsnippet
